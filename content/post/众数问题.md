---
title: C++众数问题
date: 2019-10-21 20:12:12
categories: 
  - C++
comments: true
tags:
  - C++
  - 众数问题
  - 计算机算法与设计
cover_picture: ./images/th.jpg
abbrlink: d2fd1ed9
---
 QHQ-【问题描述】给定含有S个元素的多重集合S，每个元素在S中出现的次数称为该元素的重数。多重集S中重数最大的元素称为众数。例如，S={1,2,2,2,3,5}。多重数S的众数是2，其重数为3 。
<!-- more -->

---
    ```
    【问题描述】给定含有S个元素的多重集合S，每个元素在S中出现的次数称为该元素的重数。多重集S中重数最大的元素称为众数。例如，S={1,2,2,2,3,5}。多重数S的众数是2，其重数为3 。
    
    【算法设计】对于给定的由n个自然数组成的多重集S，计算S的众数及其重数。
    
    【输入形式】第1行为多重数集S中元素个数n；接下来的n行中，每行有一个自然数。
    
    【输出形式】输出文件有2行，第1行是众数，第2行是重数。
    
    【样例输入】
    
    6
    
    1
    
    2
    
    2
    
    2
    
    3
    
    5
    【样例输出】
    
    2
    
    3
    
    ```
---
    ```
    #include<iostream>
    #include<algorithm>
    using namespace std;
    #define MAXINT 10000
    int main()
    {
    	int n = 0;
    	cin >> n;
    	int a[MAXINT] = { 0 };
    	for (int i = 0; i < n; i++)
    	{
    		cin >> a[i];
    	}
    	sort(a, a + n);
    	int maxcount = 0;
    	int maxcount_index = 0;
    	int temp = 1;
    	int b[MAXINT] = { 0 };
    	b[0] = a[0];
    	int b_index = 1;
    	bool flag = false;
    	for (int i = 0; i < (n - 1); i++)
    	{
    		if (a[i] != a[i + 1])
    		{
    			b[b_index++] = a[i + 1];
    			flag = true;
    		}
    		else
    			temp++;
    		if (maxcount < temp)
    		{
    			maxcount = temp;
    			maxcount_index = (b_index - 1);
    		}
    		if (flag)
    		{
    			temp = 1;
    			flag = false;
    		}
    	}
    	cout << b[maxcount_index] << endl;
    	cout << maxcount;
    }
    ```
---
# ***Sort()*** 数组排列函数。

## 用法

  >  1、sort函数可以三个参数也可以两个参数，必须的头文件#include < algorithm>和using namespace std;
  >
  >   2、它使用的排序方法是类似于快排的方法，时间复杂度为n*log2(n)
  > 
  >  3、Sort函数有三个参数：（第三个参数可不写）
  >    
  >  （1）第一个是要排序的数组的起始地址。
  >    
  >  （2）第二个是结束的地址（最后一位要排序的地址）
  >
  >  （3）第三个参数是排序的方法，可以是从大到小也可是从小到>大，还可以不写第三个参数，此时默认的排序方法是从小到大排序。    

## 两个参数用法
    ```
    #include <iostream>
    #include <algorithm>
    int main()
    {
         int a[20]={2,4,1,23,5,76,0,43,24,65},i;
         for(i=0;i<20;i++)
          cout<<a[i]<<endl;
         sort(a,a+20);
         for(i=0;i<20;i++)
         cout<<a[i]<<endl;
         return 0;
    }
    ```    
>    ```
>    输出结果是升序排列。（两个参数的sort默认升序排序）
>    ```
---
##三个参数
```
// sort algorithm example
#include <iostream>     
#include <algorithm>    
#include <vector>       
using namespace std;

bool myfunction (int i,int j) { return (i<j); }//升序排列
bool myfunction2 (int i,int j) { return (i>j); }//降序排列

struct myclass {
  bool operator() (int i,int j) { return (i<j);}
} myobject;

int main () {
    int myints[8] = {32,71,12,45,26,80,53,33};
  vector<int> myvector (myints, myints+8);               // 32 71 12 45 26 80 53 33

  // using default comparison (operator <):
  sort (myvector.begin(), myvector.begin()+4);           //(12 32 45 71)26 80 53 33

  // using function as comp
  sort (myvector.begin()+4, myvector.end(), myfunction); // 12 32 45 71(26 33 53 80)
    //std::sort (myints,myints+8,myfunction);不用vector的用法

  // using object as comp
  sort (myvector.begin(), myvector.end(), myobject);     //(12 26 32 33 45 53 71 80)

  // print out content:
  cout << "myvector contains:";
  for (std::vector<int>::iterator it=myvector.begin(); it!=myvector.end(); ++it)//输出
  cout << ' ' << *it;
  cout << '\n';

  return 0;
}
```
---
## string 使用反向迭代器来完成逆序排列
```
#include <iostream>
using namespace std;
int main()
{
     string str("cvicses");
     string s(str.rbegin(),str.rend());
     cout << s <<endl;
     return 0;
}
//输出：sescivc
```